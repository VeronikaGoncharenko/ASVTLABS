# Лабораторная работа №2
## Пример №1
### Использование async и await для асинхронности 
Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и при этом более экономно использовать потоки. 
```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        // Создаем и запускаем четыре задачи асинхронно.
        Task task1 = LoadDataAsync("Задача 1", 1000);
        Task task2 = LoadDataAsync("Задача 2", 2000);
        Task task3 = LoadDataAsync("Задача 3", 1500);
        Task task4 = LoadDataAsync("Задача 4", 500);

        // Запускаем все задачи параллельно и ждем их завершения.
        await Task.WhenAll(task1, task2, task3, task4);
    }

    // Асинхронный метод для загрузки данных.
    private static async Task LoadDataAsync(string taskName, int delay)
    {
        Console.WriteLine($"{taskName} начинает загрузку данных...");

        // Ожидание длительной операции с использованием Task.Delay вместо Thread.Sleep.
        await Task.Delay(delay);

        Console.WriteLine($"{taskName} завершила загрузку данных.");
    }
}
```
**Объяснение**

В заголовке метода используем модификатор `async`. Он не делает автоматически метод асинхронным. 
Он лишь указывает, что данный метод может содержать одно или несколько выражений `await`

`static async Task Main()`

Далее создаем и запускаем 4 задачи асинхронно, передавая имя задачи и задержку в миллисекундах, с помощью `Task task1 = LoadDataAsync("Задача 1", 1000)`. 

Используем метод `Task.WhenAll`. Данный метод ожидает, пока все переданные задачи не завершатся. 
Это позволяет запустить задачи параллельно и продолжить выполнение программы, когда все задачи завершены.

После используем метод `LoadDataAsync`. Необходим для выполнения асинхронной задержки для имитации длительной операции. 

Для вывода стартового сообщения используем : `Console.WriteLine($"{taskName} начинает загрузку данных...")`

Для того, чтобы поток не блокировался и задачи выполнялсь параллельно используем метод `await Task.Delay(delay)`

**Вывод сообщения о завершении:**

Выводим сообщение о завершении с помощью `Console.WriteLine($"{taskName} завершила загрузку данных.")` 
    
Результат работы программы:

![image](https://github.com/user-attachments/assets/d747a974-b432-420b-9bec-5652f240e3eb)

**Вывод**

В примере №1 мы имитируем асинхронную загрузку данных для четырех разных задач. Каждая задача выполняется параллельно без блокировки основной программы. 
`Метод await Task.Delay` позволяет асинхронно ожидать завершения каждой операции, что дает возможность другим асинхронным задачам тоже выполняться во время ожидания.

## Пример №2
### Использование метода синхронизации Mutex
Mutex используется для разграничения доступа потоков к общим ресурсам. 
Мьютекс представляет объект, который может находиться в двух состояниях: заблокированном и разблокированном.
Если мьютекс заблокирован, то поток, который хочет получить этот мьютекс, должен ждать, когда другой поток освободит его (разблокирует).
```csharp
using System;
using System.Threading;

class Program
{
    // СоздаемMutex для синхронизации доступа к общему ресурсу.
    private static Mutex mutex = new Mutex();

    static void Main()
    {
        // Создаем четыре потока с разными действиями.
        Thread thread1 = new Thread(() => WriteToResource("Поток 1", 5));
        Thread thread2 = new Thread(() => WriteToResource("Поток 2", 5));
        Thread thread3 = new Thread(() => WriteToResource("Поток 3", 5));
        Thread thread4 = new Thread(() => WriteToResource("Поток 4", 5));

        // Запускаем потоки.
        thread1.Start();
        thread2.Start();
        thread3.Start();
        thread4.Start();

        // Ожидаем завершения потоков.
        thread1.Join();
        thread2.Join();
        thread3.Join();
        thread4.Join();
    }

    // Метод, в котором потоки записывают данные в общий ресурс.
    private static void WriteToResource(string threadName, int times)
    {
        for (int i = 0; i < times; i++)
        {
            // Ждем, пока не получим доступ к Mutex.
            mutex.WaitOne();

            try
            {
                // Критическая секция: начинаем работу с общим ресурсом.
                Console.WriteLine($"{threadName} записывает: сообщение {i + 1}");
                Thread.Sleep(100); // Симулируем небольшую задержку для наглядности.
            }
            finally
            {
                // Освобождаем Mutex, чтобы другие потоки могли получить доступ.
                mutex.ReleaseMutex();
            }
        }
    }
}
```
**Объяснение**

Сначала мы создаем Mutex, который будет использоваться для синхронизации потоков, чтобы только один поток мог получить доступ к критической секции кода 
одновременно.

`private static Mutex mutex = new Mutex()`

Далее мы создаем 4 потока, которые выполняют метод `WriteToResource` (метод, принимающий имя потока и количество записей, которые он должен сделать)

`Thread thread1 = new Thread(() => WriteToResource("Поток 1", 5))`

Запускаем потоки с помощью `thread1.Start()`

Для ожидания завершения работы потоков используем `thread1.Join()`

Для запуска цикла для записи сообщений используем `for (int i = 0; i < times; i++)`

`mutex.WaitOne()` — поток ожидает, пока не получит право на доступ к критической секции.

Для работы с общим ресурсом используем 
`Console.WriteLine($"{threadName} записывает: сообщение {i + 1}")`  выводит сообщение от потока. Это и есть общий изменяемый ресурс.

`Thread.Sleep(100)` искусственно замедляет выполнение, чтобы лучше наблюдать за работой потоков.

Для освобождение мьютекса используем `mutex.ReleaseMutex()` 
Поток освобождает право на доступ, позволяя другим потокам войти в критическую секцию.

**Результат работы программы**

![image](https://github.com/user-attachments/assets/7428300e-349b-4b77-b4be-d94f6b6248be)

**Вывод**

Программа демонстрирует многопоточное взаимодействие с использованием Mutex для предотвращения состояния гонки, обеспечивая корректную работу 
нескольких потоков.


